method_args <- argument_dictionary[method]
method_args
# Get arguments for each method
arguments <- c(AOI, method, param, model, scenario, startd, endd, timeRes)
arguments
names(arguments) <- c("AOI", "method", "param", "model", "scenario", "startDate",
"endDate", "timeRes")
arguments
argument_dictionary <- lapply(datasets, formalArgs)
argument_dictionary
# Get arguments associated with the chosen method
method_args <- argument_dictionary[method]
method_args
# Get arguments for each method
arguments <- c(AOI, method, param, model, scenario, starts, ends, timeRes)
arguments
length(cc)
length(cc[[1]])
# Now, to use the do.call, we need vectors of all arguments
n <- length(cc[[1]])
rep(AOI, n)
AOI
rep(method, n
rep(method, n)
arguments <- c(rep(AOI, n) , rep(method, n), rep(param, n), rep(model, n), rep(scenario, n), starts, ends, rep(timeRes, n))
arguments <- c(rep.int(AOI, n) , rep(method, n), rep(param, n), rep(model, n), rep(scenario, n), starts, ends, rep(timeRes, n))
c(AOI, AOI)
lapply(1:7, function(x) AOI)
lapply(1:7, AOI)
arguments <- c(lapply(1:7, function(x) AOI), rep(method, n), rep(param, n), rep(model, n), rep(scenario, n), starts, ends, rep(timeRes, n))
arguments
names(arguments) <- c("AOI", "method", "param", "model", "scenario", "startDate",
"endDate", "timeRes")
arguments
names(arguments) <- c(rep("AOI", n), rep("method", n), rep("param", n), rep("model", n), rep("scenario", n),
rep("startDate", n),rep("endDate", n), rep("timeRes", n))
arguments
datasets
formalArgs
argument_dictionary <- lapply(datasets, formalArgs)
argument_dictionary
# Get arguments associated with the chosen method
method_args <- argument_dictionary[method]
method_args
method
names(arguments) <- c(rep("AOI", n), rep("method", n), rep("param", n), rep("model", n), rep("scenario", n),
rep("startDate", n),rep("endDate", n), rep("timeRes", n))
arguments
method_args
method_args
args <- lapply(method_args, function(k) arguments[k])[[1]]
args
if (args['endDate'] == 'NULL') args <- args[!grepl('endDate', names(args))]
argument_dictionary <- lapply(datasets, formalArgs)
argument_dictionary
datasets
method
datasets
datasets[[method]]
args
formalArgs
argument_dictionary <- lapply(datasets, formalArgs)
argument_dictionary
# Get arguments associated with the chosen method
method_args <- argument_dictionary[method]
method_args
# arguments <- c(lapply(1:7, function(x) AOI), rep(method, n), rep(param, n), rep(model, n), rep(scenario, n), starts, ends, rep(timeRes, n))
# names(arguments) <- c(rep("AOI", n), rep("method", n), rep("param", n), rep("model", n), rep("scenario", n),
#                       rep("startDate", n),rep("endDate", n), rep("timeRes", n))
arguments <- c(AOI, method, param, model, scenario, starts, ends, timeRes)
arguments
# arguments <- c(lapply(1:7, function(x) AOI), rep(method, n), rep(param, n), rep(model, n), rep(scenario, n), starts, ends, rep(timeRes, n))
# names(arguments) <- c(rep("AOI", n), rep("method", n), rep("param", n), rep("model", n), rep("scenario", n),
#                       rep("startDate", n),rep("endDate", n), rep("timeRes", n))
arguments <- c(AOI, method, param, model, scenario, timeRes)
arguments
names(arguments) <- c("AOI", "method", "param", "model", "scenario", "timeRes")
arguments
argument_dictionary <- lapply(datasets, formalArgs)
argument_dictionary
# Get arguments associated with the chosen method
method_args <- argument_dictionary[method]
method_args
args <- lapply(method_args, function(k) arguments[k])[[1]]
args
arguments <- c(AOI, method, param, model, scenario, starts[[1]], ends[[1]], timeRes)
names(arguments) <- c("AOI", "method", "param", "model", "scenario", "startDate",
"endDate", "timeRes")
argument_dictionary <- lapply(datasets, formalArgs)
# Get arguments associated with the chosen method
method_args <- argument_dictionary[method]
args <- lapply(method_args, function(k) arguments[k])[[1]]
if (args['endDate'] == 'NULL') args <- args[!grepl('endDate', names(args))]
args
ends
starts[[1]]
ends[[1]]
arguments <- c(AOI, method, param, model, scenario, starts[[1]], ends[[1]], timeRes)
names(arguments) <- c("AOI", "method", "param", "model", "scenario", "startDate",
"endDate", "timeRes")
argument_dictionary <- lapply(datasets, formalArgs)
arguments
arguments <- c(AOI, method, param, model, scenario, as.character(starts[[1]]),
as.character(ends[[1]]), timeRes)
names(arguments) <- c("AOI", "method", "param", "model", "scenario", "startDate",
"endDate", "timeRes")
arguments
argument_dictionary <- lapply(datasets, formalArgs)
argument_dictionary
# Get arguments associated with the chosen method
method_args <- argument_dictionary[method]
args <- lapply(method_args, function(k) arguments[k])[[1]]
if (args['endDate'] == 'NULL') args <- args[!grepl('endDate', names(args))]
args
# Now, we need repeated arguments for every start and end date
args
# Use these arguments for the method call
data_full <- do.call(datasets[[method]], args = args)
data_full
cl <- makeCluster(detectCores() - 1)
AOI
method
param
model
scenario
timeRes
cc
cl
# Get start and end date vector
starts <- lapply(cc[[1]], function(x) x[[1]])
ends <- lapply(cc[[1]], function(x) tail(x, n = 1))
starts
ends
# Get arguments associated with the chosen method
method_args <- argument_dictionary[method]
method_args
args <- lapply(method_args, function(k) arguments[k])[[1]]
if (args['endDate'] == 'NULL') args <- args[!grepl('endDate', names(args))]
args
typeof(args)
c(sd1, sd2)
sd1 <- "2000-01-01"
ed1 <- "2000-02-01"
sd2 <- "2000-02-02"
ed2 <- "2000-03-01"
# the whole thing at once
system.time({
p <- getPRISM(AOI, param = "tmax", startDate = sd1, endDate = ed2)
})
# the whole thing at once
system.time({
p <- getPRISM(AOI, param = "tmax", startDate = sd1, endDate = ed2)
})
# manually split dates between 2 cores?
clusterEvalQ(cl, library(climateR))
system.time({
p <- clusterMap(cl, getPRISM, startDate = c(sd1, sd2),
endDate = c(ed1, ed2),
MoreArgs = c(AOI = AOI, param = "tmax"))
})
# Try this with do.call?
cl <- makeCluster(detectCores() - 6)
cl
args
args <- c(c(AOI, AOI))
args
args <- c(c(AOI, AOI), c(param, param), c(model, model, c(scenario, scenario), c(sd1, sd2), c(ed1, ed2), c(timeRes, timeRes)))
args
names(args) <- ("AOI", "AOI", "param", "param", "model", "model", "scenario", "scenario", "startDate", "startDate", "endDate", "endDate", "timeRes", "timeRes")
names(args) <- c("AOI", "AOI", "param", "param", "model", "model", "scenario", "scenario", "startDate", "startDate", "endDate", "endDate", "timeRes", "timeRes")
args
datasets[[method]]
p <- clusterMap(cl, do.call(datasets[[method]]), args = args)
p <- clusterMap(cl, do.call(datasets[[method]], args=args), args = args)
p <- clusterMap(cl, do.call(datasets[[method]], args=args))
p <- clusterMap(cl, getMACA, args=args))
p <- clusterMap(cl, getMACA, args=args)
# AOI can come in many ways
AOI <- tryCatch({
AOI <- sf:::as_Spatial(AOI)
},
error = function(err){
return(AOI)
})
p <- clusterMap(cl, getMACA, args=args)
args
# manually split dates between 2 cores?
clusterEvalQ(cl, library(climateR))
cl
p <- clusterMap(cl, getMACA, args=args)
getMACA
datasets[[method]]
method
datasets[[method]]
datasets[[method]]
# Now, to use the do.call, we need vectors of all arguments
n <- length(cc[[1]])
arguments <- c(AOI, method, param, model, scenario, as.character(starts[[1]]),
as.character(ends[[1]]), timeRes)
names(arguments) <- c("AOI", "method", "param", "model", "scenario", "startDate",
"endDate", "timeRes")
argument_dictionary <- lapply(datasets, formalArgs)
arguments <- c(AOI, method, param, model, scenario, timeRes)
# Get start and end date vector
starts <- lapply(cc[[1]], function(x) x[[1]])
ends <- lapply(cc[[1]], function(x) tail(x, n = 1))
# Now, to use the do.call, we need vectors of all arguments
n <- length(cc[[1]])
arguments <- c(AOI, method, param, model, scenario, as.character(starts[[1]]),
as.character(ends[[1]]), timeRes)
names(arguments) <- c("AOI", "method", "param", "model", "scenario", "startDate",
"endDate", "timeRes")
argument_dictionary <- lapply(datasets, formalArgs)
# Get arguments associated with the chosen method
method_args <- argument_dictionary[method]
args <- lapply(method_args, function(k) arguments[k])[[1]]
args
if (args['endDate'] == 'NULL') args <- args[!grepl('endDate', names(args))]
args
names(args)
# Now, we want the remaining arguments without dates
args[!grepl("startDate",unlist(args))]
!grepl("startDate",unlist(args))
args
unlist(args)
# Now, we want the remaining arguments without dates
args[!grepl("startDate", unlist(args))]
names(args)
# Now, we want the remaining arguments without dates
args[!grepl("startDate", unlist(args))]
# Now, we want the remaining arguments without dates
args[!grepl("scenario", unlist(args))]
# Now, we want the remaining arguments without dates
args[!grepl("startDate", names(args))]
# Now, we want the remaining arguments without dates
args[!grepl(c("startDate", "endDate"), names(args))]
# Now, we want the remaining arguments without dates
args <- args[!grepl("startDate", names(args))]
args <- args[!grepl("startDate", names(args))]
args
args <- args[!grepl("endDate", names(args))]
args
# Try this with do.call?
cl <- makeCluster(detectCores() - 6)
datasets[[method]]
p <- clusterMap(cl, datasets[[method]], startDate = starts, endDate = ends,
MoreArgs=args)
clusterEvalQ(cl, library(climateR))
p <- clusterMap(cl, datasets[[method]], startDate = starts, endDate = ends,
MoreArgs=args)
starts
system.time({
p <- clusterMap(cl, datasets[[method]], startDate = starts, endDate = ends,
MoreArgs=args)})
stopCluster(cl)
# Try this with do.call?
cl <- makeCluster(detectCores() - 1)
clusterEvalQ(cl, library(climateR))
system.time({
p <- clusterMap(cl, datasets[[method]], startDate = starts, endDate = ends,
MoreArgs=args)})
p
# Get start and end date vector
starts <- lapply(cc[[1]], function(x) x[[1]])
ends <- lapply(cc[[1]], function(x) tail(x, n = 1))
# We need a vector of all possible arguments
n <- length(cc[[1]])
arguments <- c(AOI, method, param, model, scenario, as.character(starts[[1]]),
as.character(ends[[1]]), timeRes)
names(arguments) <- c("AOI", "method", "param", "model", "scenario", "startDate",
"endDate", "timeRes")
argument_dictionary <- lapply(datasets, formalArgs)
# Get arguments associated with the chosen method
method_args <- argument_dictionary[method]
args <- lapply(method_args, function(k) arguments[k])[[1]]
if (args['endDate'] == 'NULL') args <- args[!grepl('endDate', names(args))]
# Now, we want the remaining arguments without dates
args <- args[!grepl("startDate", names(args))]
args <- args[!grepl("endDate", names(args))]
# Try this with do.call?
system.time({
p <- clusterMap(cl, datasets[[method]], startDate = starts, endDate = ends,
MoreArgs=args)})
p
p
file
location
AOI
locale <- gsub(" ", "_", tolower(location))
locale
# Make the list of file names
fparam <- paste0(c(method, model, scenario, param), collapse = "_")
fparam
files <- file.path("data", "rasters", "test", locale, paste0(fparam, ".nc"))
files
folder <- file.path("data", "rasters", "test", locale, fparam)
folder
franges <- lapply(1:length(starts), function(i) paste0(starts[[i]], ends[[i]], collapse = "_"))
franges
starts
franges <- lapply(1:length(starts),
function(i){
paste0(gsub("-", "", starts[[i]]), gsub("-", "", ends[[i]]), collapse = "_"))
files <- file.path()
makeNC(data, savepath = file, method = method, model = model, param = param,
location = "Death Valley National Park", scenario = scenario, naval = -9999)
}, error = function(e){
print(paste(e, ": Taking a break and trying again..."))
Sys.sleep(3)
})
gsub("-", "", starts[[i]])
starts[[i]]
i = 1
gsub("-", "", starts[[i]])
paste0(gsub("-", "", starts[[i]]), gsub("-", "", ends[[i]]), collapse = "_")
franges <- lapply(1:length(starts),
function(i){
paste0(gsub("-", "", starts[[i]]), gsub("-", "", ends[[i]]), collapse = "_")
})
franges
franges <- lapply(1:length(starts),
function(i){
paste0(c(gsub("-", "", starts[[i]]), gsub("-", "", ends[[i]])), collapse = "_")
})
franges
files <- file.path(folder, franges)
files
franges <- lapply(1:length(starts),
function(i){
paste0(paste0(c(gsub("-", "", starts[[i]]), gsub("-", "", ends[[i]])),
collapse = "_"), ".nc")
})
franges
files <- file.path(folder, franges)
files
files
fstarts <- lapply(starts, function(x) gsub("-", "", x))
fstarts
fend <- lapply(ends, function(x) gsub("-", "", x))
fends <- lapply(ends, function(x) gsub("-", "", x))
fends
franges <- lapply(1:length(starts), function(x) paste0(c(starts[[i]], ends[[i]]), collapse = "_"))
franges
franges <- lapply(1:length(starts), function(x) paste0(c(fstarts[[i]], fends[[i]]), collapse = "_"))
franges
length(starts)
# We need a vector of all possible arguments
n <- length(cc[[1]])
n
franges <- lapply(1:n, function(x) paste0(c(fstarts[[i]], fends[[i]]), collapse = "_"))
franges
fileranges <- paste0(franges, ".nc")
fileranges
files <- file.path(folder, franges)
files
files <- file.path(folder, fileranges)
fileranges
files
# Get the list of rasterbricks
data <- clusterMap(cl, datasets[[method]], startDate = starts, endDate = ends,
MoreArgs=args)
data
data
files
fileranges
fileranges <- paste0(franges, ".nc")
franges
franges <- lapply(1:n, function(x) paste0(c(fstarts[[i]], fends[[i]]), collapse = "_"))
franges <- lapply(1:n, function(i) paste0(c(fstarts[[i]], fends[[i]]), collapse = "_"))
franges
fileranges <- paste0(franges, ".nc")
files <- file.path(folder, fileranges)
files
data
files
data
files
# Now save all these to the files
clusterMap(cl, makeNC, data = data, savepath = files,
MoreArgs = c(method = method, model = model, param = param,
location = location, scenario = scenario,
naval = -9999))
location = "Rocky Mountain"
method = "maca"
param = "tmax"
model = "CCSM4"
scenario = "rcp45"
startDate = "1950-01-01"
endDate =  "2099-12-31"
timeRes = "daily"
year_range = 4
plotsample = TRUE
# Subsetting by National Parks
if (!exists("parks")){
parks <- rgdal::readOGR("data/shapefiles/nps_boundary.shp")
}
# Query data and save to disk and return directory
AOI <- parks[grepl(tolower(location), tolower(parks$UNIT_NAME)),]  # <----------------There will cometimes be two (e.g. "X park" and "X preserve") so fix that
folder <- getScenario(AOI, method = method, param = param, model = model,
scenario = scenario, startDate = startDate, endDate = endDate,
timeRes = timeRes, year_range = year_range, plotsample = FALSE)
#' This will get all data for any one set of parameters, stack them, and save to s3
library(aws.s3)
library(climateR)
library(readtext)
source('R/getScenario.R')
source('R/makeNC.R')
# Subsetting by National Parks
if (!exists("parks")){
parks <- rgdal::readOGR("data/shapefiles/nps_boundary.shp")
}
# Query data and save to disk and return directory
AOI <- parks[grepl(tolower(location), tolower(parks$UNIT_NAME)),]  # <----------------There will cometimes be two (e.g. "X park" and "X preserve") so fix that
require(aws.s3)
require(climateR)
require(leaflet)
require(sf)
require(sp)
require(stringr)
source("R/parScenario.R")
# Start the timer
start <- Sys.time()
# Attributes
pmeta <- data.frame(climateR::param_meta[[method]])
longname <- pmeta$description[pmeta$common.name == param]
varunit <- pmeta$units[pmeta$common.name == param]
location <- as.character(AOI$UNIT_NAME)
locale <- gsub(" ", "_", tolower(location))
# AOI can come in many ways
AOI <- tryCatch({
AOI <- sf:::as_Spatial(AOI)
},
error = function(err){
return(AOI)
})
# Get download methods for each data set
datasets <- ls("package:climateR")
datasets <- datasets[grepl('get', datasets)]
cnames <- gsub("get", "", datasets)
cnames <- lapply(cnames, FUN = function(x) tolower(x))
names(datasets) <- cnames
if (is.null(endDate)) endDate <- 'NULL'
# We can't retrieve the whole file at once, it breaks (it breaks a lot anyway)
days <- year_range * 365 + 1
date_range <- seq(as.Date(startDate), as.Date(endDate), "days")
date_chunks <- split(date_range, ceiling(seq_along(date_range)/days))
# Each cpu should be able to handle one of these date chunks at a time
ncpu <- detectCores() - 1
core_chunks <- split(date_chunks, ceiling(seq_along(date_chunks)/ncpu))
# Iterate through each date chunk and save to file
pb <- progress::progress_bar$new(total = length(date_chunks))
pb$tick(0)
cl <- makeCluster(ncpu)
clusterEvalQ(cl, library(climateR))
cc = core_chunks[[1]]
library(climateR)
library(parallel)
# Get start and end date vector
starts <- lapply(cc[[1]], function(x) x[[1]])
ends <- lapply(cc[[1]], function(x) tail(x, n = 1))
# We need a vector of all possible arguments
n <- length(cc[[1]])
arguments <- c(AOI, method, param, model, scenario, as.character(starts[[1]]),
as.character(ends[[1]]), timeRes)
names(arguments) <- c("AOI", "method", "param", "model", "scenario", "startDate",
"endDate", "timeRes")
argument_dictionary <- lapply(datasets, formalArgs)
# Get arguments associated with the chosen method
method_args <- argument_dictionary[method]
args <- lapply(method_args, function(k) arguments[k])[[1]]
if (args['endDate'] == 'NULL') args <- args[!grepl('endDate', names(args))]
# Now, we want the remaining arguments without dates
args <- args[!grepl("startDate", names(args))]
args <- args[!grepl("endDate", names(args))]
args
# Make the list of file names
locale <- gsub(" ", "_", tolower(location))
locale
fparam <- paste0(c(method, model, scenario, param), collapse = "_")
folder <- file.path("data", "rasters", "test", locale, fparam)
fstarts <- lapply(starts, function(x) gsub("-", "", x))
fends <- lapply(ends, function(x) gsub("-", "", x))
franges <- lapply(1:n, function(i) paste0(c(fstarts[[i]], fends[[i]]), collapse = "_"))
fileranges <- paste0(franges, ".nc")
files <- file.path(folder, fileranges)
if (!file.exists(folder)) dir.create(folder, recursive = TRUE)
folder
folder <- file.path("data", "rasters", "tests", locale, fparam)
fstarts <- lapply(starts, function(x) gsub("-", "", x))
fends <- lapply(ends, function(x) gsub("-", "", x))
franges <- lapply(1:n, function(i) paste0(c(fstarts[[i]], fends[[i]]), collapse = "_"))
fileranges <- paste0(franges, ".nc")
files <- file.path(folder, fileranges)
files
folder
if (!file.exists(folder)) dir.create(folder, recursive = TRUE)
clusterMap
cl
datasets[[method]]
starts
ends
# Get the list of rasterbricks
data <- clusterMap(cl, datasets[[method]], startDate = starts, endDate = ends,
MoreArgs=args)
data <- clusterMap(cl, getMACA startDate = starts, endDate = ends,
MoreArgs=args)
data <- clusterMap(cl, getMACA, startDate = starts, endDate = ends,
MoreArgs=args)
# Get the list of rasterbricks
clusterExport(cl, datasets[[method]])
data <- clusterMap(cl, datasets[[method]], startDate = starts, endDate = ends,
MoreArgs=args)
